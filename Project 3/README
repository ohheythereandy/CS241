	For our third project in Professor’s Afework’s CS241 class, we were expected to implement a graph data structure and use it to demonstrate the relationship between cities and the roads between them. A menu was required to allow the client to interact with the graph data structure, such as allowing the user to print city info by inputting a city code to search for. The goal of this project is to demonstrate an understanding of the implementation, application, and properties of graphs. I developed the code within Intellij’s IDEA IDE, using java version “1.8.0_121” on a MacBook running OSX.
The city and road information was to be read from two URLs linking to different “,dat” files. The data in these two files were to be used as data fields to initialize the vertices and edges between the vertices. Seeing as this was the data the program was meant to be built to work with, I decided to begin my work on the project here. Reading input from the files proved to be challenging at first because of null strings being returned due to lines of whitespaces in the file. I solved this issue by simply iterating through the lines of data in the file a fixed number of size. This works because we knew the lines of data in each file beforehand.
After proving that I could successfully obtain data from the two files without an error being thrown, I worked on implementing the graph data structure. A graph is meant to show the relationship between vertices. For this assignment, our cities would be the vertex and the edges would be the distance between the vertices. Since the adjacency matrix representation made the most sense to me, I decided to use it to store the road distance information, and used an ArrayList of the city object type to hold all twenty cities. Since the weight of the edges are integer values, I made the matrix representing the edges of integer type instead of Boolean type. The integer in a given matrix index would correspond to the weight of the edge, or 0 if an edge does not exist.
The adjacency matrix representation might not have been the best design option in regards to its memory usage being wasted as roads are not bidirectional. Since roads are not bidirectional, there will almost certainly be less spaces in the matrix being used. An edge list would have solved the memory waste issue, but a Dijkstra path-finding implementation would have been challenging.
The implementation of Dijkstra’s shortest path finding algorithm in this project followed the psuedocode presented in the lectures of Professor Afework. A Boolean array of size 20(total number of vertices) represents the vertices included/ not included in the shortest path from the source vertex object passed. A parent array is also updated along with the distance array, which are both used to report data back to the client when prompted for a shortest path.
As discussed in class, the time complexity of Dijkstra’s algorithm implementation for an edge matrix is O(V^2) where V is the total number of vertices in the graph.
Overall, completing this project has provided me with a deeper understanding of a graph implementation as well an appreciation for the shortest path finding algorithm.
